### Задание 3. Трейсинг

##### Места в системе, которые следует покрыть трейсингом:
Наиболее уязвимые(с точки зрения зависания заказа) цепочки вызовов:
- Создание заказа через Internet Shop: Customer -> Internet Shop -> Shop API -> Shop DB
- Расчет стоимости изделия: MES API -> 3d storage -> MES API -> Rabbit MQ -> CRM API -> CRM db
- Подтверждение заказа для производства изделия: CRM -> CRM API -> Rabbit MQ -> MES API -> MES DB
- Получение списка активных заказов операторами: MES -> MES API -> MES db

Какие данные можно включить в контекст трейсинга:
- `trace_id` - идентификатор трейса
- `span_id` - идентификатор операции внтури трейса
- `operation_name` - название текущей операции(`CreateOrder`, `ConfirmOrder`, `CalculatePrice` и тд)
- `order_id` - идентификатор заказа
- `user_id` - идентификатор пользователя
- `operation_time_duration` - длительность операции: чтобы найти узкие места
- `operation_status` - статус операции: успешная, ошибка, таймаут
- `service_name` - название микросервиса, в котором происходит операция

##### Мотивация:
1. ускорение диагностики проблем — с трейсингом мы видим не только "кусочные" логи или метрики, но и можем собрать цельную картину прохождения одного заказа через всю цепочку микросервисов
2. улучшение качества сервиса — трейсинг помогает обнаружить задержки в цепочках обработки заказов, что поможет улучшить производительность сервиса для пользователей
3. снижение времени на решение инцидентов — с детализацией по `trace_id` и `span_id` разработчики могут быстро изолировать проблемные участки кода
4. возможная оптимизация использования ресурсов — с помощью трейсинга можно понять, где происходят избыточные/неэффективное использование ресурсов

###### На какие метрики повлияет внедрение трейсинга:
технические метрики:
- среднее время обработки заказа: трейсинг позволяет выявить, какие операции замедляют процесс обработки заказа
- доля запросов с ошибками: с помощью статуса операций (`operation_status`) можно легко идентифицировать сервисы или цепочки, которые чаще всего вызывают ошибки
- кол-во сообщений RabbitMQ, потерянных между MES и CRM

бизнес-метрики:
- процент выполненных заказов
- среднее время прохождения заказа от `SUBMITTED` до `CLOSED`
- процент заказов, зависших в статусе `PRICE_CALCULATED`
- кол-во ручных исправлений статусов в CRM
- время реакции на инциденты, ускоряется локализация проблем

##### Предлагаемое решение:
###### Технологии и новые компоненты:
1. OpenTelemetry + Jaeger, так как OpenTelemetry охватывает широкий список SDK
2. `Jaeger Collector` — новый компонент, в который все сервисы будут отправлять данные
3. `Jaeger UI` — новый компонент предоставляет UI, с помощью которого разработчики смогут искать и дебажить запросы

диаграмма: [jewerly_c4_model_task3.drawio](jewerly_c4_model_task3.drawio)

##### Компромиссы:
1. сложно заставить проприетарную систему отдавать метрики в нужном формате, может потребоваться дорогостоящая доработка
2. трейсинг — "не бесплатный" и влияет на производительность в высоконагруженных сервисах
3. если проект ещё небольшой или стартовал недавно, возможно не стоит вкладываться в трейсинг с самого начала, тк полезный выхлоп на таком масштабе будет низкий, а затраты не маленькие
4. требует доработок всех микросервисов, чтобы правильно обрабатывать запросы и не затирать `trace_id` + `span_id`

##### Аспекты безопасности:
1. доступ к Jaeger UI должен быть ограничен внутренней сетью(VPN)
2. внедрение аутентификации — зайти в Jaeger UI смогут только сотрудники компании с актуальной учетной записью и ролью "Поддержка"
3. связь между микросервисами и Jaeger Collector лучше поднять поверх TLS, чтобы не передавать `trace_id`/`span_id` в незашифрованном виде
4. в трейсах не должны передаваться перс данные пользователей, либо они должны быть замаскированны